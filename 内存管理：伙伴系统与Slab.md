https://www.huaweicloud.com/articles/63b7188d445f452f148dc953f61861e7.html

Linux内核内存管理的一项重要工作就是如何在频繁申请释放内存的情况下，避免碎片的产生。

Linux采用伙伴系统解决外部碎片的问题，采用slab解决内部碎片的问题.

1，伙伴系统（Buddy System/allocator）（以页为单位分配内存）

       用一种有效方法监视内存。保证在内核只要申请一小块内存的情况下，不会从大块连续空闲内存中截取一段，从而保证大块内存的连续性和完整性。

      在物理页面管理上实现了基于区的伙伴系统（zone based buddy system）。对不同区的内存使用单独的伙伴系统(buddy system)管理,而且独立地监控空闲页。相应接口alloc_pages(gfp_mask, order)，_ _get_free_pages(gfp_mask, order)等。

     步骤：1，把空闲页框分组为11种块链表，分别包含2的0-10次方个连续页（一个页面64k），称为页框块。最大页框块：2^10页，即4MB。2，分配内存时，优先分配最符合待分配大小的页框块。

2，Slab分配器(以字节为单位分配内存)

  （1） Slab分配器依然从buddy分配器分配内存，之后对自己申请来的内存进行细分管理。
    （2） 维护常用对象的缓存，对于常用结构体，释放后slab将内存块保持在内部列表中，并不会马上返还给伙伴系统。在请求为该类分配新的实例时，再把这块内存分配给他，节约了调用伙伴系统的时间。也提高了cpu缓存的利用率。（容易命中）

     通用Slab与专用Slab:
  (1) kmalloc-数字为通用slab，分配通用内存，内存块大小固定了，有点像伙伴系统的页框块分配策略。
   （2）专用slab，分配恰好满足申请的内存大小的内存块。

    slab源码实现：
	• include/linux/slab_def.h
	• include/linux/slab.h
	• mm/slab.c


3、常用的内存分配函数

__get_free_pages;  最原始的内存分配方式，直接从伙伴系统中获取原始页框，返回值为第一个页框的起始地址。

kmem_cache_create / kmem_cache_alloc;  基于slab分配器的一种内存分配方式，适用于反复分配释放同一大小内存块的场合。

kmalloc: kmalloc是内核中最常用的一种内存分配方式，它通过调用kmem_cache_alloc函数来实现。分配连续物理内存，适用于内存小，使用频率高的场景。

vmalloc: 分配一段线性连续，物理不连续的地址，带来的好处是一次可以分配较大块的内存。适用于请求频率不高，内存访问时间要求不高的场景。

dma_alloc_coherent：申请DMA内存，一次最多申请4M（2^10页）。

ioremap：ioremap是一种更直接的内存“分配”方式，使用时直接指定物理起始地址和需要分配内存的大小，然后将该段 物理地址映射到内核地址空间。（比较危险）

Boot Memory（alloc_bootmem）：分配大量的连续物理内存，上述的分配函数都不能满足，就只能用比较特殊的方式，在Linux内 核引导阶段来预留部分内存。


使用场景：

1，__get_free_pages直接对页框进行操作4MB适用于分配较大量的连续物理内存
2，kmem_cache_alloc基于slab机制实现128KB适合需要频繁申请释放相同大小内存块时使用
3，kmalloc基于kmem_cache_alloc实现128KB最常见的分配方式，需要小于页框大小的内存时可以使用
4，vmalloc建立非连续物理内存到虚拟地址的映射物理不连续，适合需要大内存，但是对地址连续性没有要求的场合
5，dma_alloc_coherent基于__alloc_pages实现4MB适用于DMA操作
6，ioremap实现已知物理地址到虚拟地址的映射适用于物理地址已知的场合，如设备驱动
7，alloc_bootmem在启动kernel时，预留一段内存，内核看不见小于物理内存大小，内存管理要求较高
